@import domain.IdAndDescription
@import domain.EnumEntryOther
@(
    label: String,
    items: IndexedSeq[_ <: IdAndDescription],
    form: Form[_],
    field: String,
    idPrefix: String,
    withOther: Option[_ <: EnumEntryOther] = None,
    columns: Int = 1
)(implicit fc: views.html.b3.B3FieldConstructor, messagesProvider: MessagesProvider)

@fullField = @{withOther.map(_ => s"$field.entries").getOrElse(field)}
@fullFieldWithIndex(i: Int) = @{withOther.map(_ => s"$field.entries[$i]").getOrElse(s"$field[$i]")}

@partionedItems = @{
  val nonOtherItems = items.filter(item => withOther.isEmpty || item.id != withOther.get.id).map(item => Html(
    b3.checkbox(form(s"$fullField[]"),
      'id -> s"$idPrefix-${item.id}",
      'value -> item.id,
      '_text -> item.description,
      'checked -> form(fullField).indexes.exists(i => form(fullFieldWithIndex(i)).value.contains(item.id))
    )(b3.clear.fieldConstructorSpecific, messagesProvider).toString
    // pass clear FC to the checkboxes so they aren't each wrapped in a form group
  ))

  val allItems = if (withOther.isEmpty) {
    nonOtherItems
  } else {
    nonOtherItems :+ play.twirl.api.HtmlFormat.fill(scala.collection.immutable.Seq(
      Html(
        b3.checkbox(form(s"$fullField[]"),
          'id -> s"$idPrefix-${withOther.get.id}",
          'value -> withOther.get.id,
          '_text -> withOther.get.label,
          'checked -> form(fullField).indexes.exists(i => form(fullFieldWithIndex(i)).value.contains(withOther.get.id)),
          Symbol("data-toggle") -> "optional-subform",
          Symbol("data-target") -> s"#$idPrefix-${withOther.get.id}-value"
        )(b3.clear.fieldConstructorSpecific, messagesProvider).toString
      ),
      Html(
        b3.text(form(s"$field.otherValue"),
          'id -> s"$idPrefix-${withOther.get.id}-value"
        )(b3.clear.fieldConstructorSpecific, messagesProvider).toString
      )
    ))
  }

  val maxItemsPerColumn = Math.ceil(allItems.size / columns.toDouble).toInt
  allItems.zipWithIndex.groupBy { case (_, i) => i / maxItemsPerColumn }.mapValues(_.map(_._1))
    .toSeq.sortBy(_._1).map(_._2)
}

@b3.free('_label -> label,
  '_class -> form(field).error.map(_ => "has-error").getOrElse("")
) {

  <div class="row">
    @partionedItems.map { group =>
      <div class="col-md-@{12 / columns}">
        @group.map { item =>
          @item
        }
      </div>
    }
  </div>

  @form(field).error.map { error =>
    <span class="help-block">@error.format</span>
  }
}